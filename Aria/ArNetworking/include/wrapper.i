
%{
/* SWIG wrapper.i for ArNetworking */
%}

#ifdef SWIGPYTHON
%module(docstring="Python wrapper library for ArNetworking", directors="1") ArNetworkingPy
#else
# ifdef SWIGJAVA
%module(docstring="Java wrapper library for ArNetworking", directors="1") ArNetworkingJava
# else
%module(docstring="Wrapper library for ArNetworking", directors="1") ArNetworking
# endif
#endif

#ifdef SWIGIMPORTED
#warning Imported ArNetworking wrapper
#endif

%feature("autodoc", "1");
/*
%feature("directors", "1");*/ /* Enable on all classes. */

%{
#include <cstddef>
#include "Aria.h"
#include "ArNetworking.h"
#include "ArClientHandlerRobotUpdate.h"
#include "ArClientRatioDrive.h"
#include "ArServerModeJogPosition.h"
#include "../include/wrapper_ExtraClasses.h"
%}
%warnfilter(451) ArUtil;


/* Import all of Aria's wrapper classes */
#ifndef SWIG_IMPORTED_ARIA
#warning ArNetworking importing ARIA wrapper configuration...
%import ../include/wrapper.i
#define SWIG_IMPORTED_ARIA 1
#endif


/* In Java, we need to import the Aria package's namespace */
%typemap(javaimports) SWIGTYPE %{import com.mobilerobots.Aria.*;%}
%pragma(java) jniclassimports=%{import com.mobilerobots.Aria.*; %}
%pragma(java) moduleimports=%{import com.mobilerobots.Aria.*; %}



/* In order for other modules (ARNL, etc.) to be able to use  
   ARIA classes in java, some java methods generated by SWIG must be public
   rather than protected.  For Swig 3.0 some macros change this, but for
   SWIG 1.3 we have to redefine that generated code here rather than letting
   SWIG generate it. See section 25.9.9 of the Swig 3.0 documentation 
   and section 21.9.9 of the Swig 1.3 documentation. The JAVABODY macros
   were added is Swig 2.0.5. */

#ifdef SWIGJAVA
#if SWIG_VERSION >= 0x020050

SWIG_JAVABODY_PROXY(public, public, SWIGTYPE)
SWIG_JAVABODY_TYPEWRAPPER(public, public, public, SWIGTYPE)

#else

%typemap(javabody) SWIGTYPE %{
  private long swigCPtr;
  protected boolean swigCMemOwn;

  /* for internal use by swig only */
  public $javaclassname(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  /* for internal use by swig only */
  public static long getCPtr($javaclassname obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }
%}

%typemap(javabody_derived) SWIGTYPE %{
  private long swigCPtr;

  /* for internal use by swig only */
  public $javaclassname(long cPtr, boolean cMemoryOwn) {
    super($imclassname.SWIG$javaclassnameUpcast(cPtr), cMemoryOwn); // Swig 1.3
    //super($imclassname.$javasclassname_SWIGUpcast(cPtr), cMemoryOwn); // Swig 3.0
    swigCPtr = cPtr;
  }

  /* for internal use by swig only */
  public static long getCPtr($javaclassname obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }
%}


%typemap(javabody) SWIGTYPE *, SWIGTYPE &, SWIGTYPE [], SWIGTYPE (CLASS::*) %{
  private long swigCPtr;

  /* for internal use by swig only */
  public $javaclassname(long cPtr, boolean bFutureUse) {
    swigCPtr = cPtr;
  }

  protected $javaclassname() {
    swigCPtr = 0;
  }

  /* for internal use by swig only */
  public static long getCPtr($javaclassname obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }
%}
#endif
#endif

/* todo do the same for csharp */


/* In Python, use typemaps to convert functions to functors: */
#ifdef SWIGPYTHON

%{
#include "../include/wrapper_Functors.h"
%}



/*
%{

  class ArPyFunctor_ServerData : 
    public ArFunctor2<ArServerClient*, ArNetPacket*>
  {
  protected:
    PyObject *pyFunction;
  public:
    ArPyFunctor_ServerData(PyObject* _f) : 
      pyFunction(_f),
      ArFunctor2<ArServerClient*, ArNetPacket*>()
    {
      Py_INCREF(pyFunction);
    }

    ~ArPyFunctor_ServerData() {
      Py_DECREF(pyFunction);
    }

    virtual void invoke() {
      Py_FatalError("ArPyFunctor_ServerData (for <ArServerClient*, ArNetPacket*>) invoked with no arguments!");
    }

    virtual void invoke(ArServerClient *cli) {
      Py_FatalError("ArPyFunctor_ServerData must be invoked with exactly 2 arguments (ArServerClient*, ArNetPacket*), 1 given.");
    }

    virtual void invoke(ArServerClient *cli, ArNetPacket *pkt)
    {
      PyObject *args = PyTuple_New(2);
      PyObject *cliObj = SWIG_Python_NewPointerObj(cli, SWIGTYPE_p_ArServerClient, 0);
      PyObject *pktObj = SWIG_Python_NewPointerObj(pkt, SWIGTYPE_p_ArNetPacket, 0);
      PyTuple_SetItem(args, 0, cliObj);
      PyTuple_SetItem(args, 1, pktObj);
      PyObject *r = PyObject_CallObject(pyFunction, args);
      if(!r)
      {
        fputs("** ArPyFunctor_ServerData: Error calling Python function: ", stderr);
        PyErr_Print();
      }
      Py_DECREF(args);
    }

    virtual const char* getName() {
      return (const char*) PyString_AsString(PyObject_Str(pyFunction));
    }
  };


%}
*/

%typemap(in) ArFunctor1<ArNetPacket *>* {
  $1 = new ArPyFunctor1<ArNetPacket *>($input);
}
%typecheck(SWIG_TYPECHECK_POINTER) ArFunctor1<ArNetPacket *>* {
  $1 = PyCallable_Check($input);
}

/*
%typemap(in) ArFunctor2<ArServerClient*, ArNetPacket*>* {
  $1 = new ArPyFunctor_ServerData($input); // XXX memory leak
}
%typecheck(SWIG_TYPECHECK_POINTER) ArFunctor2<ArServerClient*, ArNetPacket*>* {
  $1 = PyCallable_Check($input);
}
*/

%typemap(in) ArFunctor2<ArServerClient*, ArNetPacket*>* {
  $1 = new ArPyFunctor2<ArServerClient*, ArNetPacket*>($input);
}
%typecheck(SWIG_TYPECHECK_POINTER) ArFunctor2<ArServerClient*, ArNetPacket*>* {
  $1 = PyCallable_Check($input);
}


%typemap(in) ArFunctor1<const char*>* {
  $1 = new ArPyFunctor1_String($input);
}
%typecheck(SWIG_TYPECHECK_POINTER) ArFunctor1<const char*>* {
  $1 = PyCallable_Check($input);
}


#endif //SWIGPYTHON

/* But in Java, just name the functor templates and enable directors so you can subclass them: */
#ifdef SWIGJAVA
%feature("director") ArFunctor1<ArServerClient*>;
%feature("director") ArFunctor1<ArNetPacket*>;
%feature("director") ArFunctor2<ArServerClient*, ArNetPacket*>;
%template(ArFunctor_ServerClient) ArFunctor1<ArServerClient*>;
%template(ArFunctor_NetPacket) ArFunctor1<ArNetPacket*>;
%template(ArFunctor_ServerData) ArFunctor2<ArServerClient*, ArNetPacket*>;
#endif



/* include files */
/* Don't include md5.h */

/* base classes */
%include "ArNetPacket.h"
%include "ArServerBase.h"
%include "ArServerMode.h"

/* derived classes */
%include "ArClientArgUtils.h"
%include "ArClientBase.h"
%include "ArClientCommands.h"
/*%include "ArClientData.h"*/
%include "ArClientFileUtils.h"
%include "ArClientHandlerConfig.h"
%include "ArClientSimpleConnector.h"
%include "ArHybridForwarderVideo.h"
%include "ArNetPacketReceiverTcp.h"
%include "ArNetPacketReceiverUdp.h"
%include "ArNetPacketSenderTcp.h"
%include "ArServerClient.h"
%include "ArServerClientIdentifier.h"
%include "ArServerClientData.h"
%include "ArServerCommands.h"
/*%include "ArServerData.h"*/
#ifndef WIN32
%include "ArServerFileUtils.h"
#endif
%include "ArServerHandlerCamera.h"
%include "ArServerHandlerCameraCollection.h"
%include "ArServerHandlerCommMonitor.h"
%include "ArServerHandlerCommands.h"
%include "ArServerHandlerConfig.h"
%include "ArServerHandlerMap.h"
%include "ArServerHandlerMapping.h"
%include "ArServerInfoDrawings.h"
%include "ArServerInfoRobot.h"
%include "ArServerInfoSensor.h"
%include "ArServerInfoStrings.h"
%include "ArServerModeDrive.h"
%include "ArServerModeIdle.h"
%include "ArServerModeRatioDrive.h"
%include "ArServerModeStop.h"
%include "ArServerModeWander.h"
%include "ArServerSimpleCommands.h"
%include "ArServerSimpleOpener.h"
%include "ArServerUserInfo.h"
%include "ArClientHandlerRobotUpdate.h"

#include "../include/wrapper_ExtraClasses.h"

%{
/* End SWIG wraper.i for ArNetworking */
%}

